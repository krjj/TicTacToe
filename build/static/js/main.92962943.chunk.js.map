{"version":3,"sources":["components/TicTacToe.js","App.js","serviceWorker.js","index.js"],"names":["GridBlock","props","value","handleClick","bgGround","className","style","backgroundColor","onClick","GridBlockCenter","handleReset","timer","e","stopPropagation","Game","state","gridMarker","Array","fill","gridColor","IsUserTurn","gameStarted","gameStartedOn","gameFinished","gameFinishedOn","timerText","winMovesX","winMovesO","this","alert","setState","Date","now","checkWinner","setInterval","txt","moment","utc","format","setTimeout","length","blocked","forEach","movePos","indexOf","result","handleGridClick","handleGameReset","set","index","el","symb","nullPos","symbCount","_","countBy","null","findIndex","X","push","O","handleGameEnd","includes","handleComputerMove","renderGridBlock","renderGridBlockCenter","React","Component","App","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.92962943.chunk.js","sourcesContent":["import React from 'react'\nimport './TicTacToe.css'\nimport _ from 'lodash'\nimport moment from 'moment'\n\nconst selectionColor = 'red'\nconst winGridColor = 'green'\n\nfunction GridBlock(props) {\n  const { value, handleClick, bgGround } = props\n  return (<div className='box' style={{ backgroundColor: bgGround }} onClick={handleClick}>\n    {value}\n  </div>)\n}\n\nfunction GridBlockCenter(props) {\n  const { value, handleClick, handleReset, bgGround, timer } = props\n  return (<div className='boxCenter' style={{ backgroundColor: bgGround }} onClick={handleClick}>\n    <button className='resetButton' onClick={(e) => { e.stopPropagation(); handleReset() }}>Reset</button>\n    <span className='timerText'>{timer}</span>\n    {value}\n  </div>)\n}\n\nclass Game extends React.Component {\n  constructor(props) {\n    super(props)\n    this.state = {\n      gridMarker: Array(9).fill(null),\n      gridColor: Array(9).fill(''),\n      IsUserTurn: true,\n      gameStarted: false,\n      gameStartedOn: 0,\n      gameFinished: false,\n      gameFinishedOn: 0,\n      timerText: '',\n      winMovesX: [],\n      winMovesO: []\n    }\n  }\n\n  handleGridClick(value) {\n    const { gridMarker, gridColor, gameStarted, gameFinished, IsUserTurn } = this.state\n\n    if (gameFinished) {\n      alert('Game has finished, reset to play again')\n      return\n    }\n\n    if (!IsUserTurn) {\n      alert('Wait for your turn')\n      return\n    }\n\n    if (!gameStarted) {\n      this.setState({\n        gameStarted: true,\n        gameStartedOn: Date.now()\n      })\n    }\n\n    if (gridMarker[value] !== null) {\n      return\n    }\n    gridMarker[value] = 'X'\n    gridColor[value] = selectionColor\n    this.setState({ gridMarker: gridMarker, gridColor: gridColor, IsUserTurn: false }, () => this.checkWinner(gridMarker))\n  }\n\n  componentDidMount() {\n    setInterval(() => {\n      let txt = ''\n      if (this.state.gameStarted && !this.state.gameFinished) {\n        txt = moment.utc(Date.now() - this.state.gameStartedOn).format('mm:ss');\n      }\n\n      if (this.state.gameFinished && this.state.gameStarted) {\n        txt = moment.utc(this.state.gameFinishedOn - this.state.gameStartedOn).format('mm:ss')\n      }\n\n      this.setState({ timerText: txt })\n    }, 1000)\n  }\n\n  handleComputerMove() {\n    if (this.state.IsUserTurn) {\n      return\n    }\n    setTimeout(() => {\n      const { winMovesX, winMovesO, gridMarker, gridColor } = this.state\n      if (winMovesO.length) { // win first\n        gridMarker[winMovesO[0]] = 'O'\n        gridColor[winMovesO[0]] = selectionColor\n      } else if (winMovesX.length) { // prevent defeat\n        gridMarker[winMovesX[0]] = 'O'\n        gridColor[winMovesX[0]] = selectionColor\n      } else if (gridMarker[0] === 'X' && gridMarker[8] === 'X') { // future attack prevention priority x-axis\n        const optimalMovePos = [7, 2, 6]\n        let blocked = false\n        optimalMovePos.forEach((e) => {\n          if (gridMarker[e] === null && blocked === false) {\n            gridMarker[e] = 'O'\n            gridColor[e] = selectionColor\n            blocked = true\n          }\n        })\n      } else if (gridMarker[2] === 'X' && gridMarker[6] === 'X') { // future attack prevention priority y-axis\n        const optimalMovePos = [1, 8, 0]\n        let blocked = false\n        optimalMovePos.forEach((e) => {\n          if (gridMarker[e] === null && blocked === false) {\n            gridMarker[e] = 'O'\n            gridColor[e] = selectionColor\n            blocked = true\n          }\n        })\n      } else { // fall back to optimal moves\n        const optimalMovePos = [4, 0, 2, 6, 8]\n        let blocked = false\n        optimalMovePos.forEach((e) => {\n          if (gridMarker[e] === null && blocked === false) {\n            gridMarker[e] = 'O'\n            gridColor[e] = selectionColor\n            blocked = true\n          }\n        })\n\n        if (!blocked) {\n          const movePos = gridMarker.indexOf((e) => e == null)\n          gridMarker[movePos] = 'O'\n          gridColor[movePos] = selectionColor\n        }\n      }\n      this.setState({ gridMarker: gridMarker, gridColor: gridColor, IsUserTurn: true }, () => this.checkWinner(gridMarker))\n    }, 750)\n  }\n\n  handleGameEnd(result) {\n    if (result === 'Draw') {\n      // alert('nobody won')\n    } else if (result === 'X') {\n      // alert('user won')\n    } else if (result === 'O') {\n      //alert('Computer won')\n    }\n    this.setState({ gameFinished: true, gameFinishedOn: Date.now() })\n  }\n\n  renderGridBlock(value) {\n    return (<GridBlock value={this.state.gridMarker[value]} bgGround={this.state.gridColor[value]} handleClick={() => { this.handleGridClick(value) }} />)\n  }\n\n  renderGridBlockCenter(value) {\n    return (<GridBlockCenter value={this.state.gridMarker[value]} bgGround={this.state.gridColor[value]} timer={this.state.timerText} handleClick={() => { this.handleGridClick(value) }} handleReset={() => { this.handleGameReset() }} />)\n  }\n\n  checkWinner(gridMarker) {\n    const winSets = [\n      [0, 1, 2],\n      [3, 4, 5],\n      [6, 7, 8],\n      [0, 3, 6],\n      [1, 4, 7],\n      [2, 5, 8],\n      [0, 4, 8],\n      [2, 4, 6]\n    ]\n    let result = null\n    const { gridColor } = this.state\n    const winMovesO = []; const winMovesX = []\n    winSets.forEach((set, index) => {\n      if (gridMarker[set[0]] && gridMarker[set[0]] === gridMarker[set[1]] && gridMarker[set[0]] === gridMarker[set[2]]) {\n        result = gridMarker[set[0]]\n        set.forEach((el) => {\n          gridColor[el] = winGridColor\n        })\n        this.setState({ gridColor: gridColor })\n      } else {\n        const symb = [gridMarker[set[0]], gridMarker[set[1]], gridMarker[set[2]]]\n        let nullPos = 0\n\n        const symbCount = _.countBy(symb)\n\n        if (symbCount.null === 1) {\n          nullPos = set[symb.findIndex((e) => e === null)]\n\n          if (symbCount.X === 2) {\n            winMovesX.push(nullPos)\n          }\n\n          if (symbCount.O === 2) {\n            winMovesO.push(nullPos)\n          }\n\n          this.setState({ winMovesX: winMovesX, winMovesO: winMovesO })\n        }\n      }\n    })\n\n    result ? this.handleGameEnd(result) : gridMarker.includes(null) ? this.handleComputerMove() : this.handleGameEnd('Draw')\n  }\n\n  handleGameReset() {\n    this.setState({\n      gridMarker: Array(9).fill(null),\n      gridColor: Array(9).fill(''),\n      IsUserTurn: true,\n      gameStarted: false,\n      gameStartedOn: 0,\n      gameFinished: false,\n      gameFinishedOn: 0,\n      timerText: '',\n      winMovesX: [],\n      winMovesO: []\n    })\n  }\n\n  render() {\n    return (\n      <div className=\"game-board\">\n        {this.renderGridBlock(0)}\n        {this.renderGridBlock(1)}\n        {this.renderGridBlock(2)}\n        {this.renderGridBlock(3)}\n        {this.renderGridBlockCenter(4)}\n        {this.renderGridBlock(5)}\n        {this.renderGridBlock(6)}\n        {this.renderGridBlock(7)}\n        {this.renderGridBlock(8)}\n      </div>\n\n    )\n  }\n}\n\nexport default Game\n","import React from 'react'\nimport './App.css'\n\nimport Game from './components/TicTacToe'\n\n\nfunction App() {\n  return (\n    <div className='App'>\n      <Game />\n    </div>\n  )\n}\n\nexport default App\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n)\n\nexport function register (config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href)\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config)\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          )\n        })\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config)\n      }\n    })\n  }\n}\n\nfunction registerValidSW (swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing\n        if (installingWorker == null) {\n          return\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              )\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration)\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.')\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration)\n              }\n            }\n          }\n        }\n      }\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error)\n    })\n}\n\nfunction checkValidServiceWorker (swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type')\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload()\n          })\n        })\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config)\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      )\n    })\n}\n\nexport function unregister () {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister()\n    })\n  }\n}\n","import React from 'react'\nimport ReactDOM from 'react-dom'\nimport './index.css'\nimport App from './App'\nimport * as serviceWorker from './serviceWorker'\n\nReactDOM.render(<App />, document.getElementById('root'))\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister()\n"],"sourceRoot":""}